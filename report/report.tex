\documentclass[journal,transmag]{IEEEtran}
\usepackage{cite}
\usepackage[pdftex]{graphicx}
% declare the path(s) where your graphic files are
\graphicspath{IMAGES/}
\DeclareGraphicsExtensions{.pdf,.jpeg,.png,.jpg}
\usepackage{amsmath}
\interdisplaylinepenalty=2500
\usepackage{algorithmic}
\usepackage{array}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfon =sf]{subfig}
\usepackage{dblfloatfix}
\usepackage{url}
\usepackage{lipsum}
\usepackage{xcolor}
\usepackage{listings}

\lstset{
	escapeinside={/*@}{@*/},
	language=Java,	
	basicstyle=\fontsize{8.5}{12}\selectfont,
	numbers=left,
	numbersep=2pt,    
	xleftmargin=2pt,
	frame=tb,
	showstringspaces=false,
	tabsize=4,
	keepspaces=true,
	showtabs=false,
	showspaces=false,
	morekeywords={inline,public,class,private,protected,struct},
	captionpos=b,
	lineskip=-0.4em,
	aboveskip=10pt,
	extendedchars=true,
	breaklines=true,
	prebreak = \raisebox{0ex}[0ex][0ex]{\ensuremath{\hookleftarrow}},
	keywordstyle=\color[rgb]{0,0,1},
	commentstyle=\color[rgb]{0.133,0.545,0.133},
	stringstyle=\color[rgb]{0.627,0.126,0.941},
}

\begin{document}

\title{SET10108 Concurrent and Parallel Systems \linebreak Coursework 1}

\markboth{40161070}{}
% The only time the second header will appear is for the odd numbered pages after the title page when using the twoside option.

\IEEEtitleabstractindextext{
	
\begin{abstract}
 
\end{abstract}

\begin{IEEEkeywords}
	I
\end{IEEEkeywords}}

\maketitle

\section{Introduction}
 Today learning how to parallelise is very important computer games can be some of the worst games and competent parallelization can allow great graphics to be run on an average pc. This allows people skilled in parallelization to be very successful in a variety of jobs very relevant today.\par\noindent
 
 In this coursework the task was too parallelise a ray tracer to improve the performance using multi-threading and CPU- level parallelism. Then evaluate the performance and compare it to the serial performance.  The ways that the algorithm was evaluated was through changing several aspects such as samples per pixel and size of image. These aspects were then measured through speed up and efficiency and recorded.
 

\section{Inital Analysis}
To perform the initial analysis of the program the program was run serval times changing several variables. These test showed that the algorithm performed well with small sample sizes however similarly to most serial programs the system struggled with large sample sizes showing a bottleneck exist as the time taken to complete the complete the picture increased exponentially the larger the sample per pixel this was also the case for changing the size of the image where a larger image would take a greater time. However while testing adding more objects to the scene it was noted that this had little effect on the overall time taken to complete which made sense as this did not add more pixels to the image but changed the picture itself.
	\subsection{Parallelizable Places}
To look for places to parallelize the easiest places to look is at the for loops as threads allow the for loops to be run simultaneously. The largest for loop inside the algorithm was the multi for loop that calculate what colour each pixel is shown below. It was decided that this would be the part of the algorithm that would be parallelised.
\newpage 
\lstinputlisting[caption = The code that was be parallised]{./sourceCode/hello.cpp}
	
\section{Methodology}
To test the parallelisation of the ray cast algorithm three aspects of the code were tested; the number of samples per pixel, changing the size of the image and adding other objects to the scene. To keep the results consistent only one value was tested at a time. The other values were kept constant while the tests were being run. The time taken to complete the image was measured, this was repeated 10 time and an average was calculated. These test were time consuming so other computers were used however all the computers used had same graphics card and CPU to allow the tests to stay legitimate. 
	\subsubsection{OpenMP}
	The first approach was to use OpenMP, OpenMP is a library to support shared memory concurrency allowing it to be portable and added easily to the program. The reason OpenMP was used over the first for loop as the first approach was because itâ€™s simple to use which means it will also be rather robust as it will help the programmer tag parts of potential concurrency. It can also be used in conjunction with other approaches allowing more threading to be used.
	\subsubsection{Multi-Threading}
	\subsubsection{Algorithimic Skeletons}
	\subsubsection{CPU-Paralleism}

\section{Results}
	\subsection{Discussion}
	
\section{Conclusion}
	

\newpage


\bibliographystyle{IEEEtran}
\bibliography{fuckingBibliography}

\end{document}